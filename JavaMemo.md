### Stringインスタンスの不変性
- 不変 (immutable)
  - インスタンス化の後に内容が絶対に変化しないように設計されたクラスのこと
  - 参照やスレッドに関連したある種の複雑な不具合が、原理的に起こり得ないという特徴を保つため、プログラムのあらゆる箇所で利用されているStringにも採用されている
  - `+` に夜連結が行われた瞬間、古いインスタンスは捨てられ、連結後の情報を持つ新インスタンスが`new`により生成される
    - `+`演算子による文字列連結は内部で`new`を繰り替えること。newによるインスタンス生成は、計算などに比べて、JVMに大きな負荷がかかる
- 可変(mutable)
  - `StringBuffer` や `StringBuilder`は可変んあクラスとして設計されている
  - `append()`メソッドの呼び出しのたびにnewを行わない。バッファを拡大しつつあたらな文字列を追記していく


## 03_Collection
### データ構造(datastructure)
- データをどのようにまとめて扱うかを示したもの
- list
  - 配列のように、順序づけて格納するデータ構造nこと
### コレクションフレームワーク collectioin framework
- 様々なデータ構造に対応した、「データをまとめて格納するために入れ物クラス」がAPIとして準備されている。
- `java.util`パッケージに属し、collection-frameworkと総称されている
- 
- 単独の値を保存
  - `ArrayList``LinkedList`
    - 重複許可、順序保証(list)
  - `HashSet``LinkedHashSet``TreeSet`
    - 重複不可、順序非保証(Set)
    - 集合(set)というデータ構造を実現している
- ペアの値を保存(Map)
  - `HashMap``LinkedHashMap``TreeMap`

### コレクションクラスにはできないこと
- **インスタンスでないものは格納できない。基本データ型は格納ができない**
- プリミティブ型はラップすることで使用できるint->Integer
### リストの中身を一つずつ取り出す方法
- for
- 拡張for
- イテレータ
  - イテレータとは、箱を順番にやす矢印
  - `java.tuil.Iterator<~>`型のインスタントして扱う
    - `ArrayList<String>`の場合には、イテレータとして`Iterator<String>`を利用する
    - Iteratorを使用するサインは、`new`演算子は使用しない。リスト変数自体の`iterator()`メソッドを呼び出すことでリストの先頭をさしたイテレータのインスタンを得ることができる
  - イテレータのメソッドを呼び出すと、**そのリストよりも先頭（最初の箱よりももっと前）を指定した状態の矢印を取得している**
  - イテレータのインスタンスに対する操作
      - `hasNext()`
        - 次の要素をさせるか調査する
      - `next()`
        - 次の要素を指定し、その内容をさす
#### LinkedList
- ArrayListっと似たような動作をする
- ただしArrayListとは **クラスの内部実装に違いがある**
- LinkedListは**連結リスト**という構造を応用して作られteiru
- LinkedListが得意な操作(ArrayListが苦手な操作)
  - 要素の挿入・削除`add()``remove()`
- LinkedListが苦手な操作(ArrayListが得意な操作)
  - 指定位置の要素の取得`get()`

### コレクションのインスタンスは極力曖昧な型で取り扱うのが通なやり方
- ArrayListとLinkedListは共に、`java.util.List`インターフェースを実装している
```
java.util.List
　└ ArrayList
　└ LinkedList
```
- ざっくりListとして扱う方がメリットが大きい
  - **引数、戻り値、ローカル変数には、極力曖昧な型（インターフェイス型）を利用できないかを検討して、積極的に利用する**
- 例えば下のメソッドの役割は「リストの中身を取り出して一つずつ表示すること」
  - なのでリストの内部構造が配列であるか連結リストであるかあは関係ない。
```
public static void printList(List<String> list){
  for (String a : list){
    System.out.println(a);
  }
}
```
### Set集合
- 重複した値は無視される
- set()やget()がない。要素同士に順序がないため。添字は使えない
- 一つずつ取り出す際の順序は不明
#### Setの実装バリエーション
- LinkedHashSet
  - 値を格納した順序で整列j
- TreeSet
  - 自然順序付で整列
  - それぞれのクラスに固有の順序。Stringクラスでは辞書順になるように定義されている

### Map
- Mapは「ペアデータの集まり」であるため、Collectionインターフェイスとは継承関係にない
- 二つの情報を**key** と **value**のペアとして格納するデータ構造
- `java.util.Map`インターフェイスと`java.util.HashMap`クラスに代表される実装を用いることで、活用できる
- `Map<String, Integer>`String型のkeyと、Integer型の値value
- マップでは値の重複は許されるが、**key**の重複は許されない。同じkeyをput()すると値が上書きされる


### コレクションの応用
#### コレクションのネスト
- コレクションクラスは、要素として別のコレクションを格納することも可能
- Mapの中に、Listがネストした構造など
#### ネストで注意すること
- リストに格納されているのは、メモリのアドレス情報。
- なので、コレクションへ格納が終わった変数のインスタンスの中身を書き換えると、コレクションに格納済みの要素の中身も書き換わってしまう

# インスタンスの操作
- Javaにおける全てのクラスは、その継承関係を親へと辿ると、`java.lang.Object`クラスに行き着く
- Objectクラスが存在することのメリとお
  - 全クラスはObjectクラスで定義されたメソッドを持っていることが保証される
  - Object型変数には、あらゆるインスタンスを代入可能である
## 多くのインスタンスに共通して使える基本操作
- `toString()`
  - 文字列表現をえる
  - 関連するクラスObject
- `equals()`
  - 等価判定を行う
  - 関連するクラスObject
- `hashCode()`
  - ハッシュ値をえる
  - 関連するクラスObject
- `compareTo()`
  - 大小関係を判定する
  - 関連するクラスComparable
- `clone()`
  - 複製する
  - 関連するクラスObject, Cloneable
### toString()の操作
- 責務
  - インスタンスの内容を人が読んで理解できる文字列で表現したもの(文字列表現)として返すj
- インスタンスの中身を知り宝ったら、とにかく`toString()`を呼び出せば良い
- デバッグ作業やログ出力で役に立つ
- ただし、作成したインスタンスに、ただ`toString()`を実行しても、意味不明な出力しか返却されない
  - これは、親クラスである`Object`クラスの`toString()`メソッドを実行しているから
- **あるクラスがどのような文字列表現を返すべきかは、そのクラスを作った人にしかわからない**
- **なので、新しくクラスを作成したら、toString()をオーバーライドして、適切な文字列表現を返すように上書きする必要がある**

### 等価判定
#### 等価と等値の違い
- `equals()`メソッドは、2つの変数に入っているインスタンを比較して、等価(equivalent)であるかどうかを判定する
  - 等値(equality)とは全く別
  - equivalent(等価) equals
    - 指しているものが同じ内容であること
    - 同じアドレスでなくとも良い
    - すなわち下の場合 
    - `h1 != h2`だが`h1.equals(h2)`
```
Hero h1 = new Hero("AAA"); // 3345番地
Hero h2 = new Hero("AAA"); // 9191番地
```
  - equality(等値) ==
    - 指しているものが「完全に同一であること」
    - すなわち同じアドレスを指していること
    - 下の場合
    - `h1 == h2`
```
Hero h1 = new Hero("AAA"); // 3345番地
Hero h2 = h1;
```
- `==`演算子を用いる等値判定はJVMは簡単に行える。アドレスが同じかどうかを判定すれば良いだけだから
- 一方で、`equals()`を用いる等価判定は簡単でhないあ。
  - 二つのクラスが何を持って同一か、の基準はクラスによってまちまち
  - その判断はJVMではなく開発者が行う
  - Objectクラスに宣言済みの`equals()`メソッドの中身は、ただの等値判定ロジック

### equalsをオーバーライドした時の処理内容
- (1)自分自身が引数として渡された場合には無条件でtrue
- (2)nullが引数として渡された場合には、無条件でfalse
- (3)比較し型が異なるならば、falseを返す。（同じならば(4)に備えて、比較できるように適切にキャストする

### equalsは必ずオーバーライドすること
- クラスを作成したら必ずオーバーライドすること
- StringやInteger,DateのようなAPIクラスでは、equals()が適切にオーバーライドされているから、問題がなかった
- クラスを作成したら必ずしオーバーライドする
- オーバーライドが不要なクラス
  - そもそも等価を判定されうことが考えられないクラス（データではなく、主に処理ロジックを持っているクラス
  - 親クラスですでにオーバーライドされていて、そのロジックで問題のないクラス
### equalsをオーバーライドしても誤動作が起きることもHash系
- HashSetの内部動作
  - ArrayListのremove()は、equals()メソッドで要素を確認する
  - 一方でHashSetのremoveはそのような動作をしない。
    - 内部でnull判定やキャスト、各フィールドの等価判定を繰り返すような`equals()`メソッドをなんども呼び出していたら、**削除したい要素を探し出すために長い時間がかかり非効率だから**
- HashSetやHashMapのようなHash系のコレクションのクラスでの要素の探し方
  - 2段階で行われる
    1. 高速だが、あいまいな方法で、各要素に「だいたい同じか？」を問い合わせる
    2. 「だいたい同じ」要素にだけ、`equals()`で「厳密に同じか？」を問い合わせる
  - HashSetはだいたい同じかどうかを判定するために、**Hash値** を利用する(Hash code)
    - そのインスタンスの内容を数値として要約したもの
    - ハッシュ値の条件
      - 同じ等価なインスタンスからは、必ず同じハッシュ値が得られること
      - 異なるインスタンスからは、なるべく異なるハッシュ値が得られること
    - Javaでは「全てのオブジェクトは地震のハッシュ値を計算できるべきだある」という考えのもの、その責務をおった`hashCode()`メソッドがObjectクラスに定義されている。
      - すべてのインスタンスには`hashCode()`を呼び出された際に、ハッシュ条件に乗っ取った値を返す義務がある 
      - そのため、**hashCode()メソッドもクラスの開発者が正しくオーバーライドする必要がある**
```
class Hero
  String name;
  int hp;
  public int hashCode(){
    int result = 37;  // 適当な初期値を設定する
    result = result * 31 + name.hashCode(); // 各フィールドの値の影響を加える
    result = resutl * 31 : hp;   // 各フィールドの値の影響を加える
    return result; // 結果を返す
  }
```

### インスタ順序づけ
- `list.sort()`メソッドでもエラーは出現する。
  - 例えば、「口座を並び替える」と言っても、色々な並び替えの順序がある
- ただしあらかじめ、一般的に想定される並べ順を宣言sh知恵おけば良い。
  - 自然順序づけ
  - 自然順序づけが定めてあるクラスであれば、単なる`list.sort()`でもエラーば出ない
### Comparableインターフェイスの実装
- 自然順序を宣言するためには`java.lang.Comparable`インターフェイスを実装する
-  このインターフェースを実装すると、`compataTo()`メソッドのオーバーライドが強制されることになる
```
public class Account implements Comparable<Account> {
  int accountNumber;

  public int comparaTo(Account ob){
    if(this.number < obj.number) {
      return -1;
    }
    if(this.number > obj.number){
      return 1;
    }
    return 0;
  }
} 
```
- ※`TreeSet`クラスは内部で常に並び替えを行いながら要素を格納する
  - 基本的に`Comparable`を実装したクラスを要素として格納することを前提としたコレクションクラス
  - `Comparable`が実装されているか注意が必要
## インスタンスの複製
- インスタンスは代入してもコピーされない
- 参照情報がコピーされるだけであって、インスタンスの実体は一つのまま
```
Hero h1 =new Hero();
Hero h2 = h1;
```

- インスタンス自体を複製するためには、`clone()`メソッドを利用する

```
Hero h1 =new Hero("Yusha");
Hero h2 = h1.clone();
```
### cloneによる複製をサポートする
- `clone()`による複製をサポートするには、以下の作業が必要
1. Cloneableインターフェイスの実装
  - `java.lang.Cloneable`インターフェイスを実装して、外部に対して複製をサポートしていることをアピール
2. cloneメソッドをpublicでオーバーライドする
  - 新しいインスタンをnewで生成し、自身の全フィールドをコピーしてreturnで返す、という処理内容になる 
    - clone()をサポートした親クラスがある場合は、newではなく親の`super.clone()`を呼びインスタンを生成する
    - Java5以降では戻り値の方は自身のクラス名にする
    - Objectクラスで定義しているclone()メソッドはprotectedで宣言してあるために、外部からは呼び出せないからpublicでオーバライドする

- `Cloneable`は「clone()を実装することによって複製していることを表明する」だけに存在している
- こうした目的でも用いられるインターフェイスを、**マーカーインターフェイス**と呼ぶ。
  - 他には`java.io.Serializable`など